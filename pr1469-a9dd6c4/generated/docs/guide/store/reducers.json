{
  "id": "guide/store/reducers",
  "title": "Reducers",
  "contents": "\n\n\n  <div class=\"github-links\">\n    <a href=\"https://github.com/ngrx/platform/edit/master/projects/ngrx.io/content/guide/store/reducers.md?message=docs%3A%20describe%20your%20change...\" aria-label=\"Suggest Edits\" title=\"Suggest Edits\"><i class=\"material-icons\" aria-hidden=\"true\" role=\"img\">mode_edit</i></a>\n  </div>\n\n\n<div class=\"content\">\n<h1 id=\"reducers\">Reducers<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/store/reducers#reducers\"><i class=\"material-icons\">link</i></a></h1>\n<p>Reducers in NgRx are responsible for handling transitions from one state to the next state in your application. Reducer functions handle these transitions by determining which <a href=\"guide/store/actions\">actions</a> to handle based on the type.</p>\n<h2 id=\"introduction\">Introduction<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/store/reducers#introduction\"><i class=\"material-icons\">link</i></a></h2>\n<p>Reducer functions are pure functions in that they produce the same output for a given input. They are without side effects and handle each state transition synchronously. Each reducer function takes the latest <code><a href=\"api/store/Action\" class=\"code-anchor\">Action</a></code> dispatched, the current state, and determines whether to return a newly modified state or the original state. This guide shows you how to write reducer functions, register them in your <code><a href=\"api/store/Store\" class=\"code-anchor\">Store</a></code>, and compose feature states.</p>\n<h2 id=\"the-reducer-function\">The reducer function<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/store/reducers#the-reducer-function\"><i class=\"material-icons\">link</i></a></h2>\n<p>There are a few consistent parts of every piece of state managed by a reducer.</p>\n<ul>\n<li>An interface or type that defines the shape of the state.</li>\n<li>The arguments including the initial state or current state and the current action.</li>\n<li>The switch statement</li>\n</ul>\n<p>Below is an example of a set of actions to handle the state of a scoreboard,\nand the associated reducer function.</p>\n<p>First, define some actions for interacting with a piece of state.</p>\n<code-example language=\"ts\">\nimport { <a href=\"api/store/Action\" class=\"code-anchor\">Action</a> } from '@ngrx/store';\n\nexport enum ActionTypes {\n  IncrementHome = '[Scoreboard Page] Home Score',\n  IncrementAway = '[Scoreboard Page] Away Score',\n  Reset = '[Scoreboard Page] Score Reset',\n}\n\nexport class IncrementHome implements <a href=\"api/store/Action\" class=\"code-anchor\">Action</a> {\n  readonly <a href=\"api/store/Action#type\" class=\"code-anchor\">type</a> = ActionTypes.IncrementHome;\n}\n\nexport class IncrementAway implements <a href=\"api/store/Action\" class=\"code-anchor\">Action</a> {\n  readonly <a href=\"api/store/Action#type\" class=\"code-anchor\">type</a> = ActionTypes.IncrementAway;\n}\n\nexport class Reset implements <a href=\"api/store/Action\" class=\"code-anchor\">Action</a> {\n  readonly <a href=\"api/store/Action#type\" class=\"code-anchor\">type</a> = ActionTypes.Reset;\n\n  constructor(public payload: { home: number; away: number }) {}\n}\n\nexport <a href=\"api/store/Action#type\" class=\"code-anchor\">type</a> ActionsUnion = IncrementHome | IncrementAway | Reset;\n</code-example>\n<p>Next, create a reducer file that imports the actions and define\na shape for the piece of state.</p>\n<h3 id=\"defining-the-state-shape\">Defining the state shape<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/store/reducers#defining-the-state-shape\"><i class=\"material-icons\">link</i></a></h3>\n<p>Each reducer function is a listener of actions. The scoreboard actions defined above describe the possible transitions handled by the reducer. Import multiple sets of actions to handle additional state transitions within a reducer.</p>\n<code-example language=\"ts\">\nimport * as Scoreboard from './scoreboard.actions';\n\nexport interface <a href=\"api/store/State\" class=\"code-anchor\">State</a> {\n  home: number;\n  away: number;\n}\n</code-example>\n<p>You define the shape of the state according to what you are capturing, whether it be a single type such as a number, or a more complex object with multiple properties.</p>\n<h3 id=\"setting-the-initial-state\">Setting the initial state<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/store/reducers#setting-the-initial-state\"><i class=\"material-icons\">link</i></a></h3>\n<p>The initial state gives the state an initial value, or provides a value if the current state is <code>undefined</code>. You set the initial state with defaults for your required state properties.</p>\n<p>Create and export a variable to capture the initial state with one or\nmore default values.</p>\n<code-example language=\"ts\">\nexport const <a href=\"api/store/testing/MockStoreConfig#initialState\" class=\"code-anchor\">initialState</a>: <a href=\"api/store/State\" class=\"code-anchor\">State</a> = {\n  home: 0,\n  away: 0,\n};\n</code-example>\n<p>The initial values for the <code>home</code> and <code>away</code> properties of the state are 0.</p>\n<h3 id=\"creating-the-reducer-function\">Creating the reducer function<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/store/reducers#creating-the-reducer-function\"><i class=\"material-icons\">link</i></a></h3>\n<p>The reducer function's responsibility is to handle the state transitions in an immutable way. Define a reducer function that handles the actions for managing the state of the scoreboard.</p>\n<code-example language=\"ts\">\nexport function reducer(\n  <a href=\"api/store-devtools/StoreDevtools#state\" class=\"code-anchor\">state</a> = <a href=\"api/store/testing/MockStoreConfig#initialState\" class=\"code-anchor\">initialState</a>,\n  action: Scoreboard.ActionsUnion\n): <a href=\"api/store/State\" class=\"code-anchor\">State</a> {\n  switch (action.type) {\n    case Scoreboard.ActionTypes.IncrementHome: {\n      return {\n        ...state,\n        home: state.home + 1,\n      };\n    }\n\n    case Scoreboard.ActionTypes.IncrementAway: {\n      return {\n        ...state,\n        away: state.away + 1,\n      };\n    }\n\n    case Scoreboard.ActionTypes.Reset: {\n      return action.payload; // typed to { home: number, away: number }\n    }\n\n    default: {\n      return <a href=\"api/store-devtools/StoreDevtools#state\" class=\"code-anchor\">state</a>;\n    }\n  }\n}\n</code-example>\n<p>Reducers use switch statements in combination with TypeScript's discriminated unions defined in your actions to provide type-safe processing of actions in a reducer. Switch statements use type unions to determine the correct shape of the action being consumed in each case. The action types defined with your actions are reused in your reducer functions as case statements. The type union is also provided to your reducer function to constrain the available actions that are handled in that reducer function.</p>\n<p>In the example above, the reducer is handling 3 actions: <code>IncrementHome</code>, <code>IncrementAway</code>, and <code>Reset</code>. Each action is strongly-typed based on the provided <code>ActionsUnion</code>. Each action handles the state transition immutably. This means that the state transitions are not modifying the original state, but are returning a new state object using the spread operator. The spread syntax copies the properties from the current state into the object, creating a new reference. This ensures that a new state is produced with each change, preserving the purity of the change. This also promotes referential integrity, guaranteeing that the old reference was discarded when a state change occurred.</p>\n<div class=\"alert is-important\">\n<p><strong>Note:</strong> The spread operator only does shallow copying and does not handle deeply nested objects. You need to copy each level in the object to ensure immutability. There are libraries that handle deep copying including <a href=\"https://lodash.com\">lodash</a> and <a href=\"https://github.com/mweststrate/immer\">immer</a>.</p>\n</div>\n<p>When an action is dispatched, <em>all registered reducers</em> receive the action. Whether they handle the action is determined by the switch statement. For this reason, each switch statement <em>always</em> includes a default case that returns the previous state when the reducer function doesn't need to handle the action.</p>\n<h2 id=\"registering-root-state\">Registering root state<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/store/reducers#registering-root-state\"><i class=\"material-icons\">link</i></a></h2>\n<p>The state of your application is defined as one large object. Registering reducer functions to manage parts of your state only defines keys with associated values in the object. To register the global <code><a href=\"api/store/Store\" class=\"code-anchor\">Store</a></code> within your application, use the <code><a href=\"\" class=\"code-anchor\">StoreModule.forRoot()</a></code> method with a map of key/value pairs that define your state. The <code><a href=\"\" class=\"code-anchor\">StoreModule.forRoot()</a></code> registers the global providers for your application, including the <code><a href=\"api/store/Store\" class=\"code-anchor\">Store</a></code> service you inject into your components and services to dispatch actions and select pieces of state.</p>\n<code-example language=\"ts\">\nimport { NgModule } from '@angular/core';\nimport { <a href=\"api/store/StoreModule\" class=\"code-anchor\">StoreModule</a> } from '@ngrx/store';\nimport { scoreboardReducer } from './scoreboard.reducer';\n\n@NgModule({\n  imports: [StoreModule.forRoot({ game: scoreboardReducer })],\n})\nexport class AppModule {}\n</code-example>\n<p>Registering states with <code><a href=\"\" class=\"code-anchor\">StoreModule.forRoot()</a></code> ensures that the states are defined upon application startup. In general, you register root states that always need to be available to all areas of your application immediately.</p>\n<h2 id=\"register-feature-state\">Register feature state<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/store/reducers#register-feature-state\"><i class=\"material-icons\">link</i></a></h2>\n<p>Feature states behave in the same way root states do, but allow you to define them with specific feature areas in your application. Your state is one large object, and feature states register additional keys and values in that object.</p>\n<p>Looking at an example state object, you see how a feature state allows your state to be built up incrementally. Let's start with an empty state object.</p>\n<code-example language=\"ts\">\nimport { NgModule } from '@angular/core';\nimport { <a href=\"api/store/StoreModule\" class=\"code-anchor\">StoreModule</a> } from '@ngrx/store';\n\n@NgModule({\n  imports: [StoreModule.forRoot({})],\n})\nexport class AppModule {}\n</code-example>\n<p>This registers your application with an empty object for the root state.</p>\n<code-example language=\"ts\">\n{\n}\n</code-example>\n<p>Now use the <code>scoreboard</code> reducer with a feature <code>NgModule</code> named <code>ScoreboardModule</code> to register additional state.</p>\n<code-example language=\"ts\">\nimport { NgModule } from '@angular/core';\nimport { <a href=\"api/store/StoreModule\" class=\"code-anchor\">StoreModule</a> } from '@ngrx/store';\nimport { scoreboardReducer } from './scoreboard.reducer';\n\n@NgModule({\n  imports: [StoreModule.forFeature('game', scoreboardReducer)],\n})\nexport class ScoreboardModule {}\n</code-example>\n<p>Add the <code>ScoreboardModule</code> to the <code>AppModule</code> to load the state eagerly.</p>\n<code-example language=\"ts\">\nimport { NgModule } from '@angular/core';\nimport { <a href=\"api/store/StoreModule\" class=\"code-anchor\">StoreModule</a> } from '@ngrx/store';\n\n@NgModule({\n  imports: [StoreModule.forRoot({}), ScoreboardModule],\n})\nexport class AppModule {}\n</code-example>\n<p>Once the <code>ScoreboardModule</code> is loaded, the <code>game</code> key becomes a property in the object and is now managed in the state.</p>\n<code-example language=\"ts\">\n{\n  game: { home: 0, away: 0 }\n}\n</code-example>\n<p>Whether your feature states are loaded eagerly or lazily depends on the needs of your application. You use feature states to build up your state object over time and through different feature areas.</p>\n<h2 id=\"next-steps\">Next Steps<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/store/reducers#next-steps\"><i class=\"material-icons\">link</i></a></h2>\n<p>Reducers are only responsible for deciding which state transitions need to occur for a given action.</p>\n<p><a href=\"guide/effects\">Effects</a></p>\n\n</div>\n\n<!-- links to this doc:\n - guide/store\n - guide/store/actions\n-->\n<!-- links from this doc:\n - api/store-devtools/StoreDevtools#state\n - api/store/Action\n - api/store/Action#type\n - api/store/State\n - api/store/Store\n - api/store/StoreModule\n - api/store/testing/MockStoreConfig#initialState\n - guide/effects\n - guide/store/actions\n - guide/store/reducers#creating-the-reducer-function\n - guide/store/reducers#defining-the-state-shape\n - guide/store/reducers#introduction\n - guide/store/reducers#next-steps\n - guide/store/reducers#reducers\n - guide/store/reducers#register-feature-state\n - guide/store/reducers#registering-root-state\n - guide/store/reducers#setting-the-initial-state\n - guide/store/reducers#the-reducer-function\n - https://github.com/mweststrate/immer\n - https://github.com/ngrx/platform/edit/master/projects/ngrx.io/content/guide/store/reducers.md?message=docs%3A%20describe%20your%20change...\n - https://lodash.com\n-->"
}