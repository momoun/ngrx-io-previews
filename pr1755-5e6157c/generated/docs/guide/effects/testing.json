{
  "id": "guide/effects/testing",
  "title": "Testing",
  "contents": "\n\n\n  <div class=\"github-links\">\n    <a href=\"https://github.com/ngrx/platform/edit/master/projects/ngrx.io/content/guide/effects/testing.md?message=docs%3A%20describe%20your%20change...\" aria-label=\"Suggest Edits\" title=\"Suggest Edits\"><i class=\"material-icons\" aria-hidden=\"true\" role=\"img\">mode_edit</i></a>\n  </div>\n\n\n<div class=\"content\">\n<h1 id=\"testing\">Testing<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/effects/testing#testing\"><i class=\"material-icons\">link</i></a></h1>\n<h3 id=\"providemockactions\">provideMockActions<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/effects/testing#providemockactions\"><i class=\"material-icons\">link</i></a></h3>\n<p>Provides a mock test provider of the <code><a href=\"api/effects/Actions\" class=\"code-anchor\">Actions</a></code> Observable for testing effects. This works well with writing\nmarble tests and tests using the <code>subscribe</code> method on an Observable. The mock Actions will deliver a new Observable to subscribe to for each test.</p>\n<p>Details on marble tests and their syntax, as shown in the <code>hot</code> and <code>cold</code> methods, can be found in <a href=\"https://github.com/ReactiveX/rxjs/blob/master/doc/writing-marble-tests.md\">Writing Marble Tests</a>.</p>\n<p>Usage:</p>\n<code-example header=\"my.effects.spec.ts\">\nimport { TestBed } from '@angular/core/testing';\nimport { <a href=\"api/effects/testing/provideMockActions\" class=\"code-anchor\">provideMockActions</a> } from '@ngrx/effects/testing';\nimport { cold, hot } from 'jasmine-marbles';\nimport { Observable } from 'rxjs';\n\nimport { MyEffects } from './my-effects';\nimport * as MyActions from '../actions/my-actions';\n\ndescribe('My Effects', () => {\n  let effects: MyEffects;\n  let actions: Observable&#x3C;any>;\n\n  beforeEach(() => {\n    TestBed.configureTestingModule({\n      imports: [\n        // any modules needed\n      ],\n      providers: [\n        MyEffects,\n        <a href=\"api/effects/testing/provideMockActions\" class=\"code-anchor\">provideMockActions</a>(() => actions),\n        // other providers\n      ],\n    });\n\n    effects = TestBed.get(MyEffects);\n  });\n\n  it('should work', () => {\n    const action = MyActions.exampleAction();\n    const completion = MyActions.exampleActionSuccess();\n\n    // Refer to 'Writing Marble Tests' for details on '--a-' syntax\n    actions = hot('--a-', { a: action });\n    const expected = cold('--b', { b: completion });\n\n    expect(effects.someSource$).toBeObservable(expected);\n  });\n});\n</code-example>\n<p>It is also possible to use <code>ReplaySubject</code> as an alternative for marble tests:</p>\n<code-example header=\"my.effects.spec.ts\">\nimport { TestBed } from '@angular/core/testing';\nimport { <a href=\"api/effects/testing/provideMockActions\" class=\"code-anchor\">provideMockActions</a> } from '@ngrx/effects/testing';\nimport { ReplaySubject } from 'rxjs';\n\nimport { MyEffects } from './my-effects';\nimport * as MyActions from '../actions/my-actions';\n\ndescribe('My Effects', () => {\n  let effects: MyEffects;\n  let actions: ReplaySubject&#x3C;any>;\n\n  beforeEach(() => {\n    TestBed.configureTestingModule({\n      imports: [\n        // any modules needed\n      ],\n      providers: [\n        MyEffects,\n        <a href=\"api/effects/testing/provideMockActions\" class=\"code-anchor\">provideMockActions</a>(() => actions),\n        // other providers\n      ],\n    });\n\n    effects = TestBed.get(MyEffects);\n  });\n\n  it('should work', () => {\n    actions = new ReplaySubject(1);\n    actions.next(MyActions.exampleAction());\n\n    effects.someSource$.subscribe(result => {\n      expect(result).toEqual(MyActions.exampleActionSuccess());\n    });\n  });\n});\n</code-example>\n<h3 id=\"geteffectsmetadata\">getEffectsMetadata<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/effects/testing#geteffectsmetadata\"><i class=\"material-icons\">link</i></a></h3>\n<p>Returns metadata configuration for all effects in a class instance.\nUse this function to ensure that effects have proper metadata attached.</p>\n<p>Usage:</p>\n<code-example header=\"my.effects.spec.ts\">\nimport { TestBed } from '@angular/core/testing';\nimport { <a href=\"api/effects/EffectsMetadata\" class=\"code-anchor\">EffectsMetadata</a>, <a href=\"api/effects/getEffectsMetadata\" class=\"code-anchor\">getEffectsMetadata</a> } from '@ngrx/effects';\nimport { MyEffects } from './my-effects';\n\ndescribe('My Effects', () => {\n  let effects: MyEffects;\n  let metadata: <a href=\"api/effects/EffectsMetadata\" class=\"code-anchor\">EffectsMetadata</a>&#x3C;MyEffects>;\n\n  beforeEach(() => {\n    TestBed.configureTestingModule({\n      providers: [\n        MyEffects,\n        // other providers\n      ],\n    });\n\n    effects = TestBed.get(MyEffects);\n    metadata = <a href=\"api/effects/getEffectsMetadata\" class=\"code-anchor\">getEffectsMetadata</a>(effects);\n  });\n\n  it('should register someSource$ that dispatches an action', () => {\n    expect(metadata.someSource$).toEqual({ dispatch: true });\n  });\n\n  it('should register someOtherSource$ that does not dispatch an action', () => {\n    expect(metadata.someOtherSource$).toEqual({ dispatch: false });\n  });\n\n  it('should not register undecoratedSource$', () => {\n    expect(metadata.undecoratedSource$).toBeUndefined();\n  });\n});\n</code-example>\n<h3 id=\"effects-as-functions\">Effects as functions<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/effects/testing#effects-as-functions\"><i class=\"material-icons\">link</i></a></h3>\n<p>Effects can be defined as functions as well as variables. Defining an effect as a function allows you to define default values while having the option to override these variables during tests. This without breaking the functionality in the application.</p>\n<p>The following example effect debounces the user input into from a search action.</p>\n<code-example header=\"my.effects.spec.ts\">\nsearch$ = <a href=\"api/effects/createEffect\" class=\"code-anchor\">createEffect</a>(() =>\n  this.actions$.pipe(\n    <a href=\"api/effects/ofType\" class=\"code-anchor\">ofType</a>(BookActions.search),\n    debounceTime(300, asyncScheduler),\n    switchMap(...)\n  )\n);\n</code-example>\n<p>The same effect but now defined as a function, would look as follows:</p>\n<code-example header=\"my.effects.spec.ts\">\n// refactor as input properties and provide default values\nsearch$ = <a href=\"api/effects/createEffect\" class=\"code-anchor\">createEffect</a>(() => ({\n  debounce = 300,\n  scheduler = asyncScheduler\n} = {}) =>\n  this.actions$.pipe(\n    <a href=\"api/effects/ofType\" class=\"code-anchor\">ofType</a>(BookActions.search),\n    debounceTime(debounce, scheduler),\n    switchMap(...)\n  )\n);\n</code-example>\n<p>Within our tests we can now override the default properties:</p>\n<code-example header=\"my.effects.spec.ts\">\nconst actual = effects.search$({\n  debounce: 30,\n  scheduler: getTestScheduler(),\n});\n\nexpect(actual).toBeObservable(expected);\n</code-example>\n<p>Doing this has the extra benefit of hiding implementation details, making your tests less prone to break due to implementation details changes. Meaning that if you would change the <code>debounceTime</code> inside the effect your tests wouldn't have to be changed,these tests would still pass.</p>\n<h3 id=\"effects-that-use-state\">Effects that use State<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/effects/testing#effects-that-use-state\"><i class=\"material-icons\">link</i></a></h3>\n<p>The mock store can simplify testing Effects that inject State using the RxJs <code>withLatestFrom</code> operator.  The example below shows the <code>addBookToCollectionSuccess$</code> effect displaying a different alert depending on the number of books in the collection state.</p>\n<code-example header=\"collection.effects.ts\">\nimport { Injectable } from '@angular/core';\nimport { <a href=\"api/store/Store\" class=\"code-anchor\">Store</a>, <a href=\"api/store/select\" class=\"code-anchor\">select</a> } from '@ngrx/store';\nimport { <a href=\"api/effects/Actions\" class=\"code-anchor\">Actions</a>, <a href=\"api/effects/ofType\" class=\"code-anchor\">ofType</a>, <a href=\"api/effects/createEffect\" class=\"code-anchor\">createEffect</a> } from '@ngrx/effects';\nimport { tap, withLatestFrom } from 'rxjs/operators';\nimport { CollectionApiActions } from '../books/actions';\nimport * as fromBooks from '../books/reducers';\n\n@Injectable()\nexport class CollectionEffects {\n  addBookToCollectionSuccess$ = <a href=\"api/effects/createEffect\" class=\"code-anchor\">createEffect</a>(\n    () =>\n      this.actions$.pipe(\n        <a href=\"api/effects/ofType\" class=\"code-anchor\">ofType</a>(CollectionApiActions.addBookSuccess),\n        withLatestFrom(this.store.pipe(<a href=\"api/store/select\" class=\"code-anchor\">select</a>(fromBooks.getCollectionBookIds))),\n        tap(([, bookCollection]) => {\n          if (bookCollection.length === 1) {\n            window.alert('Congrats on adding your first book!');\n          } else {\n            window.alert('You have added book number ' + bookCollection.length);\n          }\n        })\n      ),\n    { dispatch: false }\n  );\n\n  constructor(\n    private actions$: <a href=\"api/effects/Actions\" class=\"code-anchor\">Actions</a>,\n    private store: <a href=\"api/store/Store\" class=\"code-anchor\">Store</a>&#x3C;fromBooks.State>\n  ) {}\n}\n</code-example>\n<p>In the test, you can use the mock store to adjust the number of books in the collection.  You provide the <code><a href=\"api/store/testing/MockStore\" class=\"code-anchor\">MockStore</a></code> an initial state containing one book. When testing the effect when two or more books are in the collection, you provide a different state using <code><a href=\"api/store/testing/MockStore#setState\" class=\"code-anchor\">setState()</a></code>.</p>\n<code-example header=\"collection.effects.spec.ts\">\nimport { TestBed } from '@angular/core/testing';\nimport { <a href=\"api/store/Store\" class=\"code-anchor\">Store</a> } from '@ngrx/store';\nimport { <a href=\"api/effects/Actions\" class=\"code-anchor\">Actions</a> } from '@ngrx/effects';\nimport { <a href=\"api/store/testing/MockStore\" class=\"code-anchor\">MockStore</a>, <a href=\"api/store/testing/provideMockStore\" class=\"code-anchor\">provideMockStore</a> } from '@ngrx/store/testing';\nimport { <a href=\"api/effects/testing/provideMockActions\" class=\"code-anchor\">provideMockActions</a> } from '@ngrx/effects/testing';\nimport { cold, hot } from 'jasmine-marbles';\nimport { Observable } from 'rxjs';\nimport { CollectionEffects } from '../books/effects';\nimport { CollectionApiActions } from '../books/actions';\nimport { Book } from '../books/models/book';\nimport * as fromBooks from '../books/reducers';\n\ndescribe('CollectionEffects', () => {\n  let effects: CollectionEffects;\n  let actions$: Observable&#x3C;any>;\n  let store: <a href=\"api/store/testing/MockStore\" class=\"code-anchor\">MockStore</a>&#x3C;fromBooks.State>;\n  const <a href=\"api/store/testing/MockStoreConfig#initialState\" class=\"code-anchor\">initialState</a> = {\n    books: {\n      collection: {\n        loaded: true,\n        loading: false,\n        <a href=\"api/entity/EntityState#ids\" class=\"code-anchor\">ids</a>: ['1'],\n      },\n    },\n  } as fromBooks.State;\n\n  const book1 = { id: '111', volumeInfo: {} } as Book;\n\n  beforeEach(() => {\n    TestBed.configureTestingModule({\n      providers: [\n        CollectionEffects,\n        <a href=\"api/effects/testing/provideMockActions\" class=\"code-anchor\">provideMockActions</a>(() => actions$),\n        <a href=\"api/store/testing/provideMockStore\" class=\"code-anchor\">provideMockStore</a>({ <a href=\"api/store/testing/MockStoreConfig#initialState\" class=\"code-anchor\">initialState</a> }),\n      ],\n    });\n\n    effects = TestBed.get(CollectionEffects);\n    actions$ = TestBed.get(<a href=\"api/effects/Actions\" class=\"code-anchor\">Actions</a>);\n    store = TestBed.get(<a href=\"api/store/Store\" class=\"code-anchor\">Store</a>);\n  });\n\n  describe('addBookToCollectionSuccess$', () => {\n    beforeEach(() => {\n      spyOn(window, 'alert');\n    });\n\n    it('should alert congratulatory message when adding the first book on success', () => {\n      const action = CollectionApiActions.addBookSuccess({ book: book1 });\n      const expected = cold('-c', { c: action });\n      actions$ = hot('-a', { a: action });\n      expect(effects.addBookToCollectionSuccess$).toBeObservable(expected);\n      expect(window.alert).toHaveBeenCalledWith(\n        'Congrats on adding your first book!'\n      );\n    });\n\n    it('should alert number of books after adding the second book', () => {\n      store.setState({\n        books: {\n          collection: {\n            loaded: true,\n            loading: false,\n            <a href=\"api/entity/EntityState#ids\" class=\"code-anchor\">ids</a>: ['1', '2'],\n          },\n        },\n      } as fromBooks.State);\n\n      const action = CollectionApiActions.addBookSuccess({ book: book1 });\n      const expected = cold('-c', { c: action });\n      actions$ = hot('-a', { a: action });\n      expect(effects.addBookToCollectionSuccess$).toBeObservable(expected);\n      expect(window.alert).toHaveBeenCalledWith('You have added book number 2');\n    });\n  });\n});\n</code-example>\n\n</div>\n\n<!-- links to this doc:\n - guide/effects\n-->\n<!-- links from this doc:\n - api/effects/Actions\n - api/effects/EffectsMetadata\n - api/effects/createEffect\n - api/effects/getEffectsMetadata\n - api/effects/ofType\n - api/effects/testing/provideMockActions\n - api/entity/EntityState#ids\n - api/store/Store\n - api/store/select\n - api/store/testing/MockStore\n - api/store/testing/MockStore#setState\n - api/store/testing/MockStoreConfig#initialState\n - api/store/testing/provideMockStore\n - guide/effects/testing#effects-as-functions\n - guide/effects/testing#effects-that-use-state\n - guide/effects/testing#geteffectsmetadata\n - guide/effects/testing#providemockactions\n - guide/effects/testing#testing\n - https://github.com/ReactiveX/rxjs/blob/master/doc/writing-marble-tests.md\n - https://github.com/ngrx/platform/edit/master/projects/ngrx.io/content/guide/effects/testing.md?message=docs%3A%20describe%20your%20change...\n-->"
}