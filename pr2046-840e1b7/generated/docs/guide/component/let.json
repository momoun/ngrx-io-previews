{
  "id": "guide/component/let",
  "title": "NgRxLet Structural Directive",
  "contents": "\n\n\n  <div class=\"github-links\">\n    <a href=\"https://github.com/ngrx/platform/edit/master/projects/ngrx.io/content/guide/component/let.md?message=docs%3A%20describe%20your%20change...\" aria-label=\"Suggest Edits\" title=\"Suggest Edits\"><i class=\"material-icons\" aria-hidden=\"true\" role=\"img\">mode_edit</i></a>\n  </div>\n\n\n<div class=\"content\">\n<h1 id=\"ngrxlet-structural-directive\">NgRxLet Structural Directive<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/component/let#ngrxlet-structural-directive\"><i class=\"material-icons\">link</i></a></h1>\n<p>The <code>*ngrxLet</code> directive serves a convenient way of binding observables to a view context (a template context).\nIt also helps with several internal processing under the hood.</p>\n<p>The current way of binding an observable to the view looks like that:</p>\n<code-example language=\"htmlmixed\">\n&#x3C;ng-container *ngIf=\"observableNumber$  | async as n\">\n  &#x3C;app-number [number]=\"n\">\n  &#x3C;/app-number>\n  &#x3C;app-number-special [number]=\"n\">\n  &#x3C;/app-number-special>\n&#x3C;/ng-container>\n</code-example>\n<p>The problem is *ngIf is also interfering with rendering and in case of a 0the component would be hidden</p>\n<p>The <em>ngrxLet directive take over several things and makes it more convenient and save to work with streams in the template\n`&#x3C;ng-container </em>ngrxLet=\"observableNumber$ as n\">`</p>\n<code-example language=\"htmlmixed\">\n&#x3C;ng-container *ngrxLet=\"observableNumber$ as n\">\n  &#x3C;app-number [number]=\"n\">\n  &#x3C;/app-number>\n&#x3C;/ng-container>\n\n&#x3C;ng-container *ngrxLet=\"observableNumber$; let n\">\n  &#x3C;app-number [number]=\"n\">\n  &#x3C;/app-number>\n&#x3C;/ng-container>\n</code-example>\n<h2 id=\"observable-context\">Observable Context<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/component/let#observable-context\"><i class=\"material-icons\">link</i></a></h2>\n<p>With the new directive, we can not only react to observed values but get the full reactive context.</p>\n<p><strong>any.component.ts</strong></p>\n<code-example language=\"typescript=\">\n@Component({\n  <a href=\"api/store/testing/MockSelector#selector\" class=\"code-anchor\">selector</a>: 'any',\n  templateUrl: 'any.component.html'\n  // Implementation works independent of the ChangeDetectionStrategy \n})\n<a href=\"api/store-devtools/DevToolsFeatureOptions#export\" class=\"code-anchor\">export</a> class LetComponent {\n  NEVER$ = NEVER;\n  EMPTY$ = EMPTY;\n  throwError$ = throwError(new Error('PROBLEM!!'))\n  of1$ = of(1);\n  interval$ = interval(1000);\n\n  constructor(public cdRef: ChangeDetectorRef) {\n  }\n}\n</code-example>\n<code-example language=\"htmlmixed=\">\n&#x3C;ng-container *ngrxLet=\"NEVER$ as n;\"> \n    &#x3C;!-- results in undefined -->\n    {{n}}\n&#x3C;/ng-container>\n\n&#x3C;ng-container *ngrxLet=\"EMPTY$ as n; let c = $complete\"> \n    &#x3C;!-- results in undefined -->\n    {{n}}, \n    &#x3C;!-- results in true -->\n    {{c}} \n&#x3C;/ng-container>\n\n&#x3C;ng-container *ngrxLet=\"throwError$ as n; let e = $error, let c = $complete\">\n &#x3C;!-- results in undefined -->\n {{n}}\n &#x3C;!-- results in error object -->\n {{e}}\n  &#x3C;!-- results in true -->\n {{c}} \n&#x3C;/ng-container>\n\n&#x3C;ng-container *ngrxLet=\"of1$ as n; let e = $error, let c = $complete\"> \n &#x3C;!-- results in 1 -->\n {{n}}\n &#x3C;!-- results in error undefined -->\n {{e}}\n  &#x3C;!-- results in true -->\n {{c}} \n&#x3C;/ng-container>\n\n&#x3C;ng-container *ngrxLet=\"interval$ as n; let e = $error, let c = $complete\">\n &#x3C;!-- results in number -->\n {{n}}\n &#x3C;!-- results in error undefined -->\n {{e}}\n  &#x3C;!-- results in undefined -->\n {{c}} \n&#x3C;/ng-container>\n</code-example>\n<p>This can be used to maintain fallback templates:</p>\n<code-example language=\"htmlmixed=\">\n&#x3C;ng-container *ngrxLet=\"interval$; let n; let e = $error, let c = $complete\">\n  &#x3C;any-component [<a href=\"api/store/testing/MockSelector#value\" class=\"code-anchor\">value</a>]=\"n\" *ngIf=\"!e &#x26;&#x26; !c\"/>\n  &#x3C;ng-container *ngIf=\"e\">\n      There is an error: {{e}}\n  &#x3C;/ng-container>\n  &#x3C;ng-container *ngIf=\"c\">\n      It completed: {{c}}\n  &#x3C;/ng-container>\n&#x3C;/ng-container>\n</code-example>\n<p><strong>Included Features:</strong></p>\n<ul>\n<li class=\"task-list-item\"><input type=\"checkbox\" disabled> Binding is always present. (<code>*ngIf=\"truthy$\"</code>)</li>\n<li class=\"task-list-item\"><input type=\"checkbox\" disabled> It takes away the multiple usages of the <code>async</code> or <code>ngrxPush</code> pipe</li>\n<li class=\"task-list-item\"><input type=\"checkbox\" disabled> A unified/structured way of handling null and undefined</li>\n<li class=\"task-list-item\"><input type=\"checkbox\" disabled> Triggers change-detection differently if <code>zone.js</code> is present or not (<code>ChangeDetectorRef.detectChanges</code> or <code>ChangeDetectorRef.markForCheck</code>)</li>\n<li class=\"task-list-item\"><input type=\"checkbox\" disabled> Triggers change-detection differently if ViewEngine or Ivy is present (<code>ChangeDetectorRef.detectChanges</code> or <code>ÉµdetectChanges</code>)</li>\n<li class=\"task-list-item\"><input type=\"checkbox\" disabled> Distinct same values in a row (distinctUntilChanged operator)                                                            </li>\n</ul>\n\n</div>\n\n<!-- links to this doc:\n - guide/component\n-->\n<!-- links from this doc:\n - api/store-devtools/DevToolsFeatureOptions#export\n - api/store/testing/MockSelector#selector\n - api/store/testing/MockSelector#value\n - guide/component/let#ngrxlet-structural-directive\n - guide/component/let#observable-context\n - https://github.com/ngrx/platform/edit/master/projects/ngrx.io/content/guide/component/let.md?message=docs%3A%20describe%20your%20change...\n-->"
}