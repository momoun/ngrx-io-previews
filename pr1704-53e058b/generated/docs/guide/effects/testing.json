{
  "id": "guide/effects/testing",
  "title": "Testing",
  "contents": "\n\n\n  <div class=\"github-links\">\n    <a href=\"https://github.com/ngrx/platform/edit/master/projects/ngrx.io/content/guide/effects/testing.md?message=docs%3A%20describe%20your%20change...\" aria-label=\"Suggest Edits\" title=\"Suggest Edits\"><i class=\"material-icons\" aria-hidden=\"true\" role=\"img\">mode_edit</i></a>\n  </div>\n\n\n<div class=\"content\">\n<h1 id=\"testing\">Testing<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/effects/testing#testing\"><i class=\"material-icons\">link</i></a></h1>\n<h3 id=\"providemockactions\">provideMockActions<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/effects/testing#providemockactions\"><i class=\"material-icons\">link</i></a></h3>\n<p>Provides a mock test provider of the <code><a href=\"api/effects/Actions\" class=\"code-anchor\">Actions</a></code> Observable for testing effects. This works well with writing\nmarble tests and tests using the <code>subscribe</code> method on an Observable. The mock Actions will deliver a new Observable to subscribe to for each test.</p>\n<p>Details on marble tests and their syntax, as shown in the <code>hot</code> and <code>cold</code> methods, can be found in <a href=\"https://github.com/ReactiveX/rxjs/blob/master/doc/writing-marble-tests.md\">Writing Marble Tests</a>.</p>\n<p>Usage:</p>\n<code-example header=\"my.effects.spec.ts\">\nimport { TestBed } from '@angular/core/testing';\nimport { <a href=\"api/effects/testing/provideMockActions\" class=\"code-anchor\">provideMockActions</a> } from '@ngrx/effects/testing';\nimport { cold, hot } from 'jasmine-marbles';\nimport { Observable } from 'rxjs';\n\nimport { MyEffects } from './my-effects';\nimport { MyActions } from '../actions/my-actions';\n\ndescribe('My Effects', () => {\n  let effects: MyEffects;\n  let actions: Observable&#x3C;any>;\n\n  beforeEach(() => {\n    TestBed.configureTestingModule({\n      imports: [\n        // any modules needed\n      ],\n      providers: [\n        MyEffects,\n        <a href=\"api/effects/testing/provideMockActions\" class=\"code-anchor\">provideMockActions</a>(() => actions),\n        // other providers\n      ],\n    });\n\n    effects = TestBed.get(MyEffects);\n  });\n\n  it('should work', () => {\n    const action = MyActions.exampleAction();\n    const completion = new MyActions.exampleActionSuccess();\n\n    // Refer to 'Writing Marble Tests' for details on '--a-' syntax\n    actions = hot('--a-', { a: action });\n    const expected = cold('--b', { b: completion });\n\n    expect(effects.someSource$).toBeObservable(expected);\n  });\n});\n</code-example>\n<p>It is also possible to use <code>ReplaySubject</code> as an alternative for marble tests:</p>\n<code-example header=\"my.effects.spec.ts\">\nimport { TestBed } from '@angular/core/testing';\nimport { <a href=\"api/effects/testing/provideMockActions\" class=\"code-anchor\">provideMockActions</a> } from '@ngrx/effects/testing';\nimport { ReplaySubject } from 'rxjs';\n\nimport { MyEffects } from './my-effects';\nimport { MyActions } from '../actions/my-actions';\n\ndescribe('My Effects', () => {\n  let effects: MyEffects;\n  let actions: ReplaySubject&#x3C;any>;\n\n  beforeEach(() => {\n    TestBed.configureTestingModule({\n      imports: [\n        // any modules needed\n      ],\n      providers: [\n        MyEffects,\n        <a href=\"api/effects/testing/provideMockActions\" class=\"code-anchor\">provideMockActions</a>(() => actions),\n        // other providers\n      ],\n    });\n\n    effects = TestBed.get(MyEffects);\n  });\n\n  it('should work', () => {\n    actions = new ReplaySubject(1);\n    actions.next(MyActions.exampleAction());\n\n    effects.someSource$.subscribe(result => {\n      expect(result).toEqual(MyActions.exampleActionSuccess());\n    });\n  });\n});\n</code-example>\n<h3 id=\"geteffectsmetadata\">getEffectsMetadata<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/effects/testing#geteffectsmetadata\"><i class=\"material-icons\">link</i></a></h3>\n<p>Returns decorator configuration for all effects in a class instance.\nUse this function to ensure that effects have been properly decorated.</p>\n<p>Usage:</p>\n<code-example header=\"my.effects.spec.ts\">\nimport { TestBed } from '@angular/core/testing';\nimport { EffectsMetadata, <a href=\"api/effects/getEffectsMetadata\" class=\"code-anchor\">getEffectsMetadata</a> } from '@ngrx/effects';\nimport { MyEffects } from './my-effects';\n\ndescribe('My Effects', () => {\n  let effects: MyEffects;\n  let metadata: EffectsMetadata&#x3C;MyEffects>;\n\n  beforeEach(() => {\n    TestBed.configureTestingModule({\n      providers: [\n        MyEffects,\n        // other providers\n      ],\n    });\n\n    effects = TestBed.get(MyEffects);\n    metadata = <a href=\"api/effects/getEffectsMetadata\" class=\"code-anchor\">getEffectsMetadata</a>(effects);\n  });\n\n  it('should register someSource$ that dispatches an action', () => {\n    expect(metadata.someSource$).toEqual({ dispatch: true });\n  });\n\n  it('should register someOtherSource$ that does not dispatch an action', () => {\n    expect(metadata.someOtherSource$).toEqual({ dispatch: false });\n  });\n\n  it('should not register undecoratedSource$', () => {\n    expect(metadata.undecoratedSource$).toBeUndefined();\n  });\n});\n</code-example>\n<h3 id=\"effects-as-functions\">Effects as functions<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/effects/testing#effects-as-functions\"><i class=\"material-icons\">link</i></a></h3>\n<p>Effects can be defined as functions as well as variables. Defining an effect as a function allows you to define default values while having the option to override these variables during tests. This without breaking the functionality in the application.</p>\n<p>The following example effect debounces the user input into from a search action.</p>\n<code-example header=\"my.effects.spec.ts\">\n@<a href=\"api/effects/Effect\" class=\"code-anchor\">Effect</a>()\nsearch$ = this.actions$.pipe(\n  <a href=\"api/effects/ofType\" class=\"code-anchor\">ofType</a>(BookActionTypes.Search),\n  debounceTime(300, asyncScheduler),\n  switchMap(...)\n)\n</code-example>\n<p>The same effect but now defined as a function, would look as follows:</p>\n<code-example header=\"my.effects.spec.ts\">\n@<a href=\"api/effects/Effect\" class=\"code-anchor\">Effect</a>()\n// refactor as input properties and provide default values\nsearch$ = ({\n  debounce = 300,\n  scheduler = asyncScheduler\n} = {}) => this.actions$.pipe(\n  <a href=\"api/effects/ofType\" class=\"code-anchor\">ofType</a>(BookActionTypes.Search),\n  debounceTime(debounce, scheduler),\n  switchMap(...)\n)\n</code-example>\n<p>Within our tests we can now override the default properties:</p>\n<code-example header=\"my.effects.spec.ts\">\nconst actual = effects.search$({\n  debounce: 30,\n  scheduler: getTestScheduler(),\n});\nexpect(actual).toBeObservable(expected);\n</code-example>\n<p>Doing this has the extra benefit of hiding implementation details, making your tests less prone to break due to implementation details changes. Meaning that if you would change the <code>debounceTime</code> inside the effect your tests wouldn't have to be changed,these tests would still pass.</p>\n\n</div>\n\n<!-- links to this doc:\n-->\n<!-- links from this doc:\n - api/effects/Actions\n - api/effects/Effect\n - api/effects/getEffectsMetadata\n - api/effects/ofType\n - api/effects/testing/provideMockActions\n - guide/effects/testing#effects-as-functions\n - guide/effects/testing#geteffectsmetadata\n - guide/effects/testing#providemockactions\n - guide/effects/testing#testing\n - https://github.com/ReactiveX/rxjs/blob/master/doc/writing-marble-tests.md\n - https://github.com/ngrx/platform/edit/master/projects/ngrx.io/content/guide/effects/testing.md?message=docs%3A%20describe%20your%20change...\n-->"
}